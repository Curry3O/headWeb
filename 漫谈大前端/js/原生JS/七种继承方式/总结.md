## 继承总结：

> new()做了什么：
    创建一个新对象
    将新对象的__proto__指向构造函数的prototype对象
    将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）
    执行构造函数中的代码（为这个新对象添加属性）
    返回新对象  

> 代码演示：
    var child = new Child();

> new操作符实际干了下面三件事：
    var child  = {};
    child.__proto__ = Child.prototype;
    Child.call(child);


> super关键字：
    - 子类中存在constructor方法的时候，需要调用super方法，并且需要在使用this关键字之前调用
    - super关键字可以用来调用父对象上的方法
    - 可以使用super来调用父对象上的静态方法
    - 不可以使用delete来删除super上的属性
    - 不可以复写super对象上的只读属性


###### 1.原型链继承:
> 核心： 
    将父类的实例作为子类的原型
> 优点：
    简单
> 缺点：
    子类之间会共享引用类型属性。
    创建子类时，无法向父类构造函数传参。


###### 2.构造函数(经典继承)：
> 核心： 
    将父类构造函数的内容复制给了子类的构造函数。这是所有继承中唯一一个不涉及到prototype的继承。
> 优点：
    避免了引用类型的属性被所有实例共享。
    可以在 Child 中向 Parent 传参。
> 缺点：
    方法都在构造函数中定义，每次创建实例都会创建一遍方法。


###### 3.组合继承(伪经典继承)：
> 核心： 
    原型式继承和构造函数继承的组合，兼具了二者的优点。
> 优点：
    可以在创建子类实例时向父类构造函数传参。
    父类的方法可以被复用。
    父类的引用属性不会被共享。
> 缺点：
    调用了两次父类的构造函数，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费。


 ###### 4.原型式继承：
> 核心：
    原型式继承的object方法本质上是对参数对象的一个浅复制。
> 优点：
    父类方法可以复用。
> 缺点：
    父类的引用属性会被所有子类实例共享。
    子类构建实例时不能向父类传递参数。


###### 5.寄生式继承：
> 核心：
    使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。
> 优点：
    寄生式继承在主要考虑对象而不是创建自定义类型和构造函数时，是十分有用的。
> 缺点：
    跟构造函数继承模式一样，每次创建对象都会创建一遍方法。(使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。)
    同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。


###### 6.寄生组合式继承
> 优点：
    这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。
    与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。
    开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。


###### 7.ES6 Class extends
> 核心：
    核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。但是，寄生组合继承是先创建子类实例this对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。
> 总结： 
    ES6 Class extends是ES5继承的语法糖。
    JS的继承除了构造函数继承之外都基于原型链构建的。
    可以用寄生组合继承实现ES6 Class extends，但是还是会有细微的差别。