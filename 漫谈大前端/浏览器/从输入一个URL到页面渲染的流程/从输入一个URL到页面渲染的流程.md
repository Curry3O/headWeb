## 1.获取IP地址

> 为什么要获取IP地址？

IP地址对应一台真实的物理机器，而且IP地址就像人的身份证是唯一的，用户请求服务器，只需要输入为该服务器分配的唯一的IP地址即可。但由于IP地址不便于记忆，因而使用较为语义化的域名来替代IP地址，而且一个域名可能对应了多个IP地址，比如用户输入www.baidu.com,该域名下对应了多个IP，域名解析服务器会根据一定的规则分配给用户其中一个IP地址。

如何获取IP地址：
- 首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步;（浏览器缓存）
- 在本地的hosts文件中是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步；（系统缓存）
- 系统缓存中没有则从路由缓存中查找，如果没有则进行下一步；（路由器缓存）
- 向本地DNS服务器（一般由本地网络接入服务器提供商提供，比如移动）发送DNS请求，本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步；（ISP DNS缓存）
- 首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；...一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址；（本地DNS服务器中没有则从其他DNS服务器中查找，其他服务器中查找的规则是递归查找，查找的顺序是根域名服务器，一级域名服务器，二级域名服务器，三级域名服务器，是递归查询）


> 关于DNS的获取流程：
DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。具体过程如下：
- 用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了
- 浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如:http://www.baidu.com/ ,, 并将这个主机名传送给DNS应用的客户端
- DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）
- 该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址
- 一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接


## 2.TCP/IP连接

> TCP三次握手建立连接
为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。(如图"三次握手.png"所示)

- 发送端首先发送一个带SYN标志的数据包给对方。(表示-->客户端：我要请求数据可以吗？)

- 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。(表示-->服务器：可以的)

- 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。(表示-->好的)
(若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包)


> 扩展：为什么要进行三次握手？如果是两次握手，如下面的对话只有前两句，有可能出现的问题是：客户端之前发送了一个连接请求报文，由于网络原因滞留在网络中，后来到达服务器端，服务器接收到该请求，就会建立连接，等待客户端传送数据。而此时客户端压根就不知道发生了什么，白白造成了服务器资源浪费。



## 3.浏览器向web服务器发送http请求

>客户机与服务器建立连接后就可以开始传输数据了，传输数据需要将用户输入的URL封装成HTTP Request请求报文，发送到服务器，服务器收到请求后会发出应答，即响应数据。

>HTTP请求报文格式：请求报头和请求主体。请求报头包括请求方式（GET/POST/DELETE/PUT）、请求资源路径、HTTP版本号，返回的信息是否需要缓存，以及客户端是否发送cookie等

>客户端请求静态资源和动态资源。

- 静态资源：如果客户端请求的是静态资源，则web服务器根据URL地址到服务器的对应路径下查找文件，然后给客户端返回一个HTTP响应，包括状态行、响应头和响应正文。

- 动态资源：如果客户端请求的是动态资源，则web服务器会调用CGI/VM执行程序完成相应的操作，如查询数据库，然后返回查询结果数据集，并将运行的结果--HTML文件返回给web服务器。Web服务器再将HTML文件返回给用户。


## 4.浏览器渲染

> 浏览器拿到HTML文件后，根据渲染规则进行渲染：

- 解析HTML，构建DOM树
- 解析CSS，生成CSS规则树
- 合并DOM树和CSS规则树，生成render树
- 布局render树
- 绘制render数、树，即绘制页面像素信息
- GPU将各层合成，结果呈现在浏览器窗口中


## 5.四次挥手

>客户端没有数据发送时就需要断开连接，以释放服务器资源。断开一个TCP连接则需要“四次握手”

- 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在FIN包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。(表示-->客户端：我没有数据要发送了，打算断开连接)

- 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。(表示-->服务器：你的请求我收到了，我这还有数据没有发送完成，你等下)

- 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。(表示-->服务器：我的数据发送完毕，可以断开连接了)

- 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。(表示-->客户端：ok,你断开连接吧（客户端独白：我将在2倍的最大报文段生存时间后关闭连接。如果我再次收到服务器的消息,我就知道服务器没有收到我的这句话,我就再发送一遍）)

> 最终服务器收到该客户端发送的消息断开连接，客户端也关闭连接。(如图"四次挥手.png"所示)


>扩展：TCP和UDP的区别

- TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立链接。

- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为TCP可靠，面向连接，不会丢失数据因此适合大数据量的交换。

- TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。

- TCP只能是1对1的，UDP支持1对1,1对多。

- TCP的首部较大为20字节，而UDP只有8字节。

- TCP是面向连接的可靠性传输，而UDP是不可靠的。