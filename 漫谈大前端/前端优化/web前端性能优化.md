## web前端性能优化
> web性能优化，主要分为前端和后台两个部分性能优化，后台性能优化决定了web能不能用，前端优化决定了其好不好用，也就是牵涉到前端用户体验和web易用性等情况，所以前端性能与用户体验是有着极大的关联的。

> 首先，前端优化之前，我们需要知道其整体性能情况，然后对整体情况进行细分与分析，了解其每一步所损耗的时间和消耗的原由，然后进行细节优化，才能达成一个整体性能质的飞越，并不是其中一部分或者一个步骤的优化就能够解决问题的，只有优化的量才能达到性能质的飞越。



### HTTP请求
#### 减少HTTP请求数量
> 80%的响应的时间是消耗在网页内容的下载上，例如：图片，样式、脚本、Flash等。所以减少请求次数以是缩短响应时间的关键之处。优化方法：
    - 合并文件：将相关代码文件进行合并
    - 从设计实现层面简化页面
    - 合理设置 HTTP缓存
    - Css Sprites：将多张图片合并成单张图片，通过css来控制什么地方显示图片的那个位置。
    - 图片映射：也是将多图拼在一起，然后通过坐标来控制。通常在页面中连续的时候才有用，比如导航条。
    - 行内图片(Base64编码): 通过编码的字符串将图片内嵌到网页文本中。



#### 避免重定向
> 重定向是一个比较常使用的技术手段，比如服务器地址进行迁移，修改了请求的url地址，这时通常会使用重定向，把访问原网址的用户重定向到新的url。

> 由于浏览器访问地址是一连串的过程，如果重定向的话，就需要在访问过程中重复发起一连串的动作，会消耗很多时间，因此避免出现多次重定向地址或资源的访问。




#### DNS预解析
> 当浏览器与web服务器建立连接时，它是需要进行DNA解析的，将域名解析为IP地址。首先我们来了解一下它的过程：
    - 先检查本地 hosts 文件中是否有映射，有则使用；
    - 查找本地 DNS 缓存，有则返回；
    - 根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；
    - 如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；
    - 根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；
    - 当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。

> 所以减少DNS的查询次数非常重要，页面加载时就尽量避免额外耗时。为了减少DNS的询次数，最好的解决方法就是在页面中减少不同的域名请求的机会。  




#### 使用CDN
> 使用内容分发网络，把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。





### 浏览器缓存
> 对一个网站而言，CSS、javascript、logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。

> 在某些时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况，可通过改变文件名实现，即更新javascript文件并不是更新javascript文件内容，而是生成一个新的JS文件并更新HTML文件中的引用。

> 使用浏览器缓存策略的网站在更新静态资源时，应采用逐量更新的方法，比如需要更新10个图标文件，不宜把10个文件一次全部更新，而是应该一个文件一个文件逐步更新，并有一定的间隔时间，以免用户浏览器忽然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。





### 页面静态资源
#### 将CSS样式表放在顶部
> 如果将css样式定义放在页面中或者页面底部，会出现短暂白屏或者某一区域短暂白板的情况，这和浏览器的运营机制有关的，不管页面如何加载，页面都是逐步呈现的。所以在每做一个页面的时候，用Link标签把每一个样式表定义放在head中。




#### 将javascript脚本放在底部
> 浏览器在加载css文件时，页面逐步呈现会被阻止，直到所有css文件加载完毕，所以要把css文件的引用放到head中去，这样在加载css文件时不会组织页面的呈现。但是对于js文件，在使用的时候，它下面所有也页面内容的呈现都会被阻塞，将脚本放在页面越靠下的地方，就意味着越多的内容能够逐步呈现。




#### 使用外部javascript和CSS
> 内联js和css其实比外部文件有更快的响应速度，那为什么还要使用外部呢？因为使用外部的js和css可以让浏览器缓存他们，这样不仅HTML文档大小减少，而且不会增加HTTP请求数量。另外，使用外部js和css可以提高组件的可复用性。




#### 组件压缩
> 通过压缩工具将js、css、html文件进行压缩，减少项目文件大小。




#### 图片优化
> 图片的优化主要是针对图片大小、格式、展现形式进行处理，对于图片资源处理网上介绍的方式有很多，在这里就不进行详细的介绍。





### 从DOM结构和标签上来优化
    - 使用语义化的标签，代码清晰简洁；
    - 减少Dom节点，增加渲染速度；
    - 使用W3C标准书写闭合小写的标签；
    - 给图片和table指定宽高，避免缩放；
    - 防止src和href值为空，当为空时，浏览器会把当前页面当做属性值重新加载；
    - css在头部位置，js在body底部位置；





### 从CSS样式上来优化
    - 使用link加载样式而不是@import（是css2提供的一种方式，不兼容，只能加载css，而且页面所有组件被加载完后才会被加载，完成前会导致‘闪烁’，link属于XHTML标签，没有兼容问题）；
    - 避免使用css表达式；
    - 避免使用css filter滤镜；
    - 使用css 缩写 如#fff，减少代码量；
    - 删除重复的css，css简化；
    - 使用CSS Sprite把同类图片合成一张，减少图片http请求；
    - 减少css查询层级，如.header .log 要好于.header .top .log；
    - 减少css查询范围，如header>div获取直系子元素要好于heade div；
    - 避免TAG标签与CLASS或ID并存：如a.top、button#submit；




### 从js上来优化
    - js尽量少用全局变量；
    - 多个js变量声明合并；
    - 不使用eval函数，不安全，性能消耗严重
    - 使用事件代理绑定事件，如将事件绑定到body上进行代理（利用冒泡原理将事件加到父级上，能够给动态增加的元素进行数据绑定）；
    - 避免频繁的操作DOM节点，使用innerHTML代替
    - 减少对象查找，如a.data.box1.name的查找方式非常耗性能，尽可能的将它定义在变量里；
    - 类型转换，把数字转字符串使用var str=‘’+1；浮点数转成整形使用Math.floor()或者Math.round();
    - js对字符串进行循环操作，譬如替换、查找应该使用正则表达式；
    - 删除重复的js
    - 使用setTimeout来避免页面失去响应
    - 使用hash-table来优化查找





### 其他方面进行优化
    - 尽量合并js和css，对js和css进行压缩，可以缩短文件传输时间；
    - 使用CDN加速
    -  减少Cookie的大小，使用无cookie的域，客户端请求静态文件的时候，减少 Cookie 的反复传输对主域名的影响；
    - 为文件头指定Expirs,使内容具有缓存性；
    - 减少DNS查询，权衡；
    - 避免在html标签中写style属性




### 资源的预加载(prebrowsing)
> 预加载是浏览器对将来可能被使用资源的一种暗示，一些资源可以在当前页面使用到，一些可能在将来的某些页面中被使用。作为开发人员，我们比浏览器更加了解我们的应用，所以我们可以对我们的核心资源使用该技术。



#### DNS 预解析dns-prefetch
```html
<link rel="dns-prefetch"href="//example.com">
<!-- 请求这个域名下的文件时就不需要等待DNS查询了,也就是说在浏览器请求资源时，DNS查询就已经准备好了 -->
<!-- 该技术对使用第三方资源特别有用，比如jquery等 -->
```



#### 预连接 Preconnect
```html
<!-- 与 DNS 预解析类似，preconnect 不仅完成 DNS 预解析，同时还将进行 TCP 握手和建立传输层协议 -->
<link rel="preconnect" href="http://example.com">
```
> 现代浏览器都试着预测网站将来需要哪些连接，然后预先建立 socket 连接，从而消除昂贵的 DNS 查找、TCP 握手和 TLS 往返开销。然而，浏览器还不够聪明，并不能准确预测每个网站的所有预链接目标。好在，在 Firefox 39+ 和 Chrome 46+ 中我们可以使用 preconnect 告诉浏览器我们需要进行哪些预连接。




#### 预获取 Prefetching
```html
<!-- 顾名思义，提前加载资源（未用到），首先要确定这个资源一定会在未来用到，然后提前加载，放入浏览器缓存中 -->
<link rel="prefetch" href="image.png">
``` 
> prefetch很适用于优化webfonts的性能，但预获取还依赖于一些条件，某些预获取可能会被浏览器忽略，例如从一个非常缓慢的网络中获取一个庞大的字体文件。并且，Firefox 只会在浏览器闲置时进行资源预获取。




#### 优先级Subresource
> 这个也是预获取方式，只是不同的是，指定的预获取资源具有最高的优先级，在所有 prefetch 项之前进行
```html
<link rel="subresource" href="styles.css">
```



#### 预渲染 Prerender
```html
<!-- Prerender 预先加载的资源文件，也就是说可以让浏览器提前加载指定页面的所有资源 -->
<link rel="prerender" href="http://example.com/index.html">
```



#### 未来 Preload
```html
<!-- Preload 建议允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源 -->
<link rel="preload" href="http://example.com/image.png">
<!-- 存在兼容性 -->
```




### 总结
#### 优化原则
    - 1. 尽可能的减少 HTTP 的请求数    content
    - 2. 使用 CDN（Content Delivery Network）    server
    - 3. 添加 Expires 头(或者 Cache-control )    server
    - 4. Gzip 组件    server
    - 5. 将 CSS 样式放在页面的上方    css
    - 6. 将脚本移动到底部（包括内联的）    javascript
    - 7. 避免使用 CSS 中的 Expressions    css
    - 8. 将 JavaScript 和 CSS 独立成外部文件    javascript css
    - 9. 减少 DNS 查询    content
    - 10. 压缩 JavaScript 和 CSS (包括内联的)    javascript css
    - 11. 避免重定向    server
    - 12. 移除重复的脚本    javascript
    - 13. 配置实体标签（ETags）    css
    - 14. 使 AJAX 缓存




#### 规则总结
优化方向|优化手段
--|:--:
请求数量|合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等
请求带宽|开启服务器GZip，精简JavaScript，移除重复脚本，图像优化（包括图片大小kb）
缓存利用|使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存
页面结构|将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出
代码校验|避免CSS表达式，避免重定向